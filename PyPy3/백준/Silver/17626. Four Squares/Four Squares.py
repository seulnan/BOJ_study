'''
요구사항 분석
모든 자연수는 넷 혹은 그 이하의 제곱수 합으로 표현가능
어떤 자연수는 복수의 방법으로 표현됨 ex 26 = 25+1 =16+9+1 두개로 가능

n이 주어질때, "최소개수"의 제곱수 합으로 표현 해야함
'''

'''
문제의 키포인트찾기
최소개수??
타겟에 대해 작은 수들 중에서 가장 큰 제곱수를 계속 찾아서 빼면되는일아님? 아근데 그러면 안맞을 확률있음
그리디로 하면 안맞을 확률있음 12=9+1+1+1임;;=4+4+4??

그러면 항상 맞는 방법을 쓰려면??
뭘 더 비교할까??뭘 더 기억해야해??

"n을 만들때 어디에 뭘 더해야해?? 마지막과정이 뭐야??"

N=(N-k의제곱수)+k의제곱수
dp[n]=dp[n-k의제곱수]+1 이런식으로 쭉.

n-k의 제곱수는 0보다 같커야됨. 인덱스니까.

제약조건
n>k의제곱수
루트 n>k
'''

'''
dp의 교훈: 일단 최악이라고 가정하고 나중에 더 좋은답이 나오면 바꾼다
dp[n]에 말도안되게 큰 값-> 최악임.
그게 뭐임?
전부 1의 제곱만 쓰는 경우
n=1을 n번더함
그래서 n번
dp[n]=n **dp의 초기값 설정***
'''

import sys,math
input=sys.stdin.readline

N=int(input())
dp=[0]*(N+1)

for i in range(1,N+1):
    dp[i]=i #최악으로 다 초기값 설정, 적어도 이 i보다는 값이 커질수없음 더 최악일수없음

for i in range(1,N+1):
    # k범위는 1부터 루트 n까지
    for k in range(1, int(math.sqrt(i)+1)):
        dp[i]=min(dp[i],dp[i-k*k]+1)

print(dp[N])
