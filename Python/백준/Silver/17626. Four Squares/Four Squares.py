'''
요구사항 분석
모든 자연수는 넷 혹은 그 이하의 제곱수 합으로 표현가능
어떤 자연수는 복수의 방법으로 표현됨 ex 26 = 25+1 =16+9+1 두개로 가능

n이 주어질때, "최소개수"의 제곱수 합으로 표현 해야함
'''

'''
문제의 키포인트찾기
최소개수??
타겟에 대해 작은 수들 중에서 가장 큰 제곱수를 계속 찾아서 빼면되는일아님? 아근데 그러면 안맞을 확률있음
그리디로 하면 안맞을 확률있음 12=9+1+1+1임;;=4+4+4??

그러면 항상 맞는 방법을 쓰려면??
뭘 더 비교할까??뭘 더 기억해야해??

"n을 만들때 어디에 뭘 더해야해?? 마지막과정이 뭐야??"

N=(N-k의제곱수)+k의제곱수
dp[n]=dp[n-k의제곱수]+1 이런식으로 쭉.

n-k의 제곱수는 0보다 같커야됨. 인덱스니까.

제약조건
n>k의제곱수
루트 n>k
'''

'''
dp의 교훈: 일단 최악이라고 가정하고 나중에 더 좋은답이 나오면 바꾼다
dp[n]에 말도안되게 큰 값-> 최악임.
그게 뭐임?
전부 1의 제곱만 쓰는 경우
n=1을 n번더함
그래서 n번
dp[n]=n **dp의 초기값 설정***
'''

# import sys,math
# input=sys.stdin.readline

# N=int(input())
# dp=[0]*(N+1)

# for i in range(1,N+1):
#     dp[i]=i #최악으로 다 초기값 설정, 적어도 이 i보다는 값이 커질수없음 더 최악일수없음

# for i in range(1,N+1):
#     # k범위는 1부터 루트 n까지
#     for k in range(1, int(math.sqrt(i)+1)):
#         dp[i]=min(dp[i],dp[i-k*k]+1)

# print(dp[N])

'''
시간초과남
예상이유:
1. pypy3이 아니라? -> 정답. 실제로 해보니 맞음

좀더 최적화된 풀이는 없을까?
-> 생각해보니 제곱수 4개이하로 쓰면된다는 특징을 사용안함.
'''

'''
최적화시키려면? 반복문쓰지말고. 수학적 성질을 활용해서 문제 구조 자체를 바꾸자.
어차피 케이스네개밖에없으니까 걍 각 케이스가 어케 나오는지 생각해봐.
1. 만약 N이 완전 제곱수면, 즉 sqrt했는데 정수라면? -> 1
2. 만약 N이 a^2+b^2형태면 -> 2
    근데 그걸 어케 알지??어케 빠르게판단?? 걍 브루트포스 ㄱㄱ
    a, b 범위는?? a^2+b^2=N 이니까 a,b 범위는 0부터 루트N까지.
    범위가 줄어든 브루트포스 N최대 50,000 이니까 대략 223번 -> 완전 적음.

    N-a^2=b^2 그러면 a를 0부터 루트 n까지 돌려보면서 뺀게 제곱수인지를 보면 되겠네.
3. 그럼 4개는 왜 4개여야할까? 왜 2개랑 3개로 커버가 안될까?? 아!
    제곱수하나빼도 제곱수가 아님.거기에 뭘 더한거야.제곱수더하기 제곱수=노제곱수인게 더해진거임 3-4개는

아모르겠다. 예시를 보자.

25=25 -> 1

26=25+1 -> 2

11339= -> 3

뭔가 dp를 썼으니까 규칙이 있을거같은데.

34567= -> 4
이게 왜 4지. 큰숫자하기싫으니까 작은거부터
++) 모듈러 연산은 2의 거듭제곱부터 의심
1 1
4 4
9 1
16 0 0
25 1 1
36 0 4
49 1 1

4+1+1+1 = 7 8로 나눈 나머지 4개를 이렇게 더해야함.
홀수의 제곱수 3개 더하고 2,6,10,14,18, 이렇게 제곱수중 하나 더하는거임
'''

import sys,math
input=sys.stdin.readline

n=int(input())

# 제곱수인가 판별하는 함수
def is_square(x:int) -> bool:
    r=int(math.isqrt(x))
    return r*r==x

if is_square(n):
    print(1)
    sys.exit()

limit=int(math.isqrt(n))
for a in range(1, limit+1):
    if is_square(n-a*a):
        print(2)
        sys.exit()

# 3. 네 개가 강제되는 형태인지
# n = 4^k * (8m + 7) 이면 3개로 불가능 -> 최소 4
m = n
while m % 4 == 0:
    m //= 4
if m % 8 == 7:
    print(4)
else:
    print(3)
