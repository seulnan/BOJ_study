'''
요구사항 분석
인쇄하고자 하는 문서를 먼저 요청된 것을 먼저 인쇄한다.
1. 큐의 가장 앞에 있는 문서 중ㅛ도 확인
2. 인쇄하지않고 큐의 가ㅇ 뒤에 재배치

A B C D
2 1 4 3

B C D A
1 4 3 2

C D A B
4 3 2 1

C 4 출력

D A B
3 2 1

어떤 한 문서가 몇번째로 인쇄되는지 알아내는 것

N(문서의개수-큐를 두는법) M(인덱스)
1(문서의개수) 0(몇번째로 인쇄되었는지 궁금한 문서. 맨 왼쪽.)
5

4(문서의개수) 2(몇번째로 인쇄되었는지 궁금한 문서. 세번쨰.)
1 2 3 4

4 1 2 3

엥?? 몇번째로 인쇄되는지?그러면 걍 내림차순해서 몇번째인지 알면되는거아냐
아근데 마지막케이스에서 같은 숫자일때가 안되는구나 -> 이것만 따로 처리하기에는 동점처리면에서 큐에서 밀려나는과정 & 정보가 사라져서 답이 안나옴. 일일이 인덱스설정하는건 더귀찮음
-> 즉, 과정이 결과에 영향을 준다. 정렬보다 시뮬레이션

6 0
1* 1 9 1 1 1

9 1 1 1 1* 1

일일이 다 시뮬하면 시간부족되지않을까??
안전함. 각 문서는 앞에서 나왔다가 뒤로 돌아가는 행동을 하긴함.
하지만 출력되면 제거되고, 중요도 비교도 빠르게 하면 ㄱㅊ음

시뮬 문제는 동작 자체는 단순하고, 판단을 빠르게 하는 보조 자료구조가 핵심.

!!!!여기서 핵심!!!!
진짜 큐로 돌리되, 매번 "뒤에 더 높은게 있나"를 O(n)으로 찾지말자.
시뮬병목은 "동작 자체"가 아니라 "매 단계에서 비싼 검사"를 하는 순간에 생김.

-> 현재 앞에 있는 문서 중요도가 남아있는 중요도들 중 최댓값이면 출력한다.(출력조건 중 내 뒤에 더 큰게있으면 을 깔끔하게 말할 수 있음)
-> 실제 문서 순서를 유지하는 큐 & 남아있는 중요도 최댓값 빠르게 알 수 있는
캐싱?? 포인터?? -> 내림차순 포인터를 사용하자.


'''

import sys
input=sys.stdin.readline
from collections import deque

a=int(input()) # 일단 반복횟수를 지정해야됨

for i in range(a):
    n,m=map(int, input().split())
    prior=list(map(int, input().split())) # 한줄로 여러개 숫자를 입력받아 정수리스트 만들기

    # 1. 실제 프린터큐: 우선순위, 원래 인덱스
    # 위 예시에서는 (2,0), (1,1), (4,2), (3,3)
    q=deque((prior[i],i) for i in range(n))

    # 남아있는 문서들의 우선순위를 내림차순으로 정렬
    # 즉, 지금 출력되어야하는 중요도. 즉 남아있는 것들 중 최댓값을 포인터로 관리
    sorted_prior=sorted(prior, reverse=True)

    idx=0 # 남아있는 것 중 현재목표의 위치

    count=0 # 결과값 출력(각 테스트 케이스에 대해 문서가 몇 번째로 인쇄되는지)

    while True:
        p,i=q.popleft() # 일단 앞에서 하나 뽑아. p는 중요도, i는 원래 인덱스

        # 만약 p가 최대값이랑 일치한다?출력해야지
        if p==sorted_prior[idx]:
            count+=1
            idx+=1

            # 출력된 문서가 만약 우리가 찾던거라면 종료(m이랑 같아야함)
            if i==m:
                print(count)
                break
        # 최댓값아니면 일단 맨 뒤로 다시 보내야함.
        else:
            q.append((p,i))
